/**
 * @file OBJExporter.cpp
 * @brief Implementation of OBJ export with materials and elevation-based coloring
 */

#include "MultiFormatExporter.hpp"
#include "../core/TopographicMesh.hpp"
#include <fstream>
#include <iomanip>
#include <algorithm>

namespace topo {

// ColorMapper implementations are in MultiFormatExporter.cpp to avoid duplicate symbols

// ============================================================================
// OBJExporter Implementation
// ============================================================================

bool OBJExporter::export_mesh(const TopographicMesh& mesh, const std::string& filename) const {
    // Compute elevation range for coloring
    auto bbox = mesh.compute_bounding_box();
    double min_elevation = bbox.min_z.value_or(0.0);
    double max_elevation = bbox.max_z.value_or(100.0);
    
    return export_mesh_with_elevation_materials(mesh, filename, min_elevation, max_elevation);
}

bool OBJExporter::export_mesh_with_elevation_materials(
    const TopographicMesh& mesh,
    const std::string& filename,
    double min_elevation,
    double max_elevation) const {
    
    // Prepare export data
    auto export_data = prepare_export_data(mesh, min_elevation, max_elevation);
    
    // Write OBJ file
    bool obj_success = write_obj_file(export_data, filename);
    
    // Write material file if requested
    bool mtl_success = true;
    if (options_.include_materials && !export_data.materials.empty()) {
        std::string mtl_filename = filename.substr(0, filename.find_last_of('.')) + ".mtl";
        mtl_success = write_material_file(export_data.materials, mtl_filename);
    }
    
    return obj_success && mtl_success;
}

bool OBJExporter::export_layers(
    const std::vector<TopographicMesh>& layers,
    const std::string& filename,
    const std::vector<std::string>& layer_names) const {
    
    std::ofstream file(filename);
    if (!file.is_open()) {
        return false;
    }
    
    file << std::fixed << std::setprecision(6);
    file << "# OBJ file generated by Topographic Generator\n";
    file << "# Multiple layers combined\n\n";
    
    // Write material library reference if needed
    if (options_.include_materials) {
        std::string mtl_name = filename.substr(0, filename.find_last_of('.')) + ".mtl";
        std::string mtl_basename = mtl_name.substr(mtl_name.find_last_of('/') + 1);
        file << "mtllib " << mtl_basename << "\n\n";
    }
    
    std::vector<Material> all_materials;
    size_t vertex_offset = 0;
    size_t normal_offset = 0;
    
    for (size_t layer_idx = 0; layer_idx < layers.size(); ++layer_idx) {
        const auto& mesh = layers[layer_idx];
        
        // Compute elevation range for this layer
        auto bbox = mesh.compute_bounding_box();
        double min_elev = bbox.min_z.value_or(0.0);
        double max_elev = bbox.max_z.value_or(100.0);
        
        auto export_data = prepare_export_data(mesh, min_elev, max_elev);
        
        // Write group/object name
        std::string layer_name = (layer_idx < layer_names.size()) ? 
            layer_names[layer_idx] : ("layer_" + std::to_string(layer_idx));
        file << "g " << layer_name << "\n";
        file << "o " << layer_name << "\n\n";
        
        // Write vertices
        for (const auto& vertex : export_data.vertices) {
            file << "v " << vertex.x() << " " << vertex.y() << " " << vertex.z() << "\n";
        }
        
        // Write normals if included
        if (options_.include_normals) {
            for (const auto& normal : export_data.normals) {
                file << "vn " << normal.x() << " " << normal.y() << " " << normal.z() << "\n";
            }
        }
        
        // Write texture coordinates if included
        if (options_.include_texture_coords) {
            for (const auto& tc : export_data.texture_coords) {
                file << "vt " << tc[0] << " " << tc[1] << "\n";
            }
        }
        
        file << "\n";
        
        // Write faces with material assignments
        for (size_t face_idx = 0; face_idx < export_data.faces.size(); ++face_idx) {
            const auto& face = export_data.faces[face_idx];
            
            // Set material if needed
            if (options_.include_materials && face_idx < export_data.material_ids.size()) {
                int material_id = export_data.material_ids[face_idx];
                if (material_id >= 0 && material_id < static_cast<int>(export_data.materials.size())) {
                    file << "usemtl " << export_data.materials[material_id].name << "\n";
                }
            }
            
            // Write face (1-based indexing in OBJ)
            file << "f ";
            for (int i = 0; i < 3; ++i) {
                size_t vertex_idx = face[i] + vertex_offset + 1;
                file << vertex_idx;
                
                if (options_.include_texture_coords) {
                    file << "/" << vertex_idx;
                }
                
                if (options_.include_normals) {
                    if (!options_.include_texture_coords) {
                        file << "/";
                    }
                    file << "/" << (vertex_idx + normal_offset);
                }
                
                if (i < 2) file << " ";
            }
            file << "\n";
        }
        
        file << "\n";
        
        // Update offsets for next layer
        vertex_offset += export_data.vertices.size();
        if (options_.include_normals) {
            normal_offset += export_data.normals.size();
        }
        
        // Collect materials for combined MTL file
        for (auto& material : export_data.materials) {
            material.name = layer_name + "_" + material.name;
            all_materials.push_back(material);
        }
    }
    
    file.close();
    
    // Write combined material file
    if (options_.include_materials && !all_materials.empty()) {
        std::string mtl_filename = filename.substr(0, filename.find_last_of('.')) + ".mtl";
        return write_material_file(all_materials, mtl_filename);
    }
    
    return true;
}

// ============================================================================
// Private Helper Methods
// ============================================================================

OBJExporter::ExportData OBJExporter::prepare_export_data(
    const TopographicMesh& mesh,
    double min_elevation,
    double max_elevation) const {
    
    ExportData data;
    
    // Reserve space
    data.vertices.reserve(mesh.num_vertices());
    data.faces.reserve(mesh.num_triangles());
    
    if (options_.include_normals) {
        data.normals.reserve(mesh.num_vertices());
    }
    
    if (options_.include_texture_coords) {
        data.texture_coords.reserve(mesh.num_vertices());
    }
    
    // Process vertices
    for (size_t i = 0; i < mesh.num_vertices(); ++i) {
        const auto& vertex = mesh.get_vertex(static_cast<VertexId>(i));
        data.vertices.push_back(vertex.position);
        
        if (options_.include_normals) {
            data.normals.push_back(vertex.normal);
        }
        
        if (options_.include_texture_coords) {
            // Generate texture coordinates based on position
            float u = static_cast<float>((vertex.position.x() - min_elevation) / 
                                       (max_elevation - min_elevation));
            float v = static_cast<float>((vertex.position.y() - min_elevation) / 
                                       (max_elevation - min_elevation));
            data.texture_coords.push_back({u, v});
        }
    }
    
    // Generate materials if elevation coloring is enabled
    if (options_.elevation_coloring && options_.include_materials) {
        ColorMapper color_mapper(options_.color_scheme);
        data.materials = color_mapper.generate_elevation_materials(
            min_elevation, max_elevation, options_.elevation_bands);
    }
    
    // Process triangles
    for (size_t i = 0; i < mesh.num_triangles(); ++i) {
        const auto& triangle = mesh.get_triangle(static_cast<TriangleId>(i));
        
        // Skip invalid triangles
        if (triangle.vertices[0] == static_cast<VertexId>(-1)) {
            continue;
        }
        
        data.faces.push_back({
            static_cast<int>(triangle.vertices[0]),
            static_cast<int>(triangle.vertices[1]),
            static_cast<int>(triangle.vertices[2])
        });
        
        // Assign material based on triangle elevation
        if (options_.elevation_coloring && options_.include_materials && !data.materials.empty()) {
            // Compute triangle centroid elevation
            double centroid_elevation = 0.0;
            for (int j = 0; j < 3; ++j) {
                centroid_elevation += mesh.get_vertex(triangle.vertices[j]).position.z();
            }
            centroid_elevation /= 3.0;
            
            int material_id = assign_material_by_elevation(
                centroid_elevation, min_elevation, max_elevation, data.materials.size());
            data.material_ids.push_back(material_id);
        } else {
            data.material_ids.push_back(0);  // Default material
        }
    }
    
    return data;
}

bool OBJExporter::write_obj_file(const ExportData& data, const std::string& filename) const {
    std::ofstream file(filename);
    if (!file.is_open()) {
        return false;
    }
    
    file << std::fixed << std::setprecision(6);
    file << "# OBJ file generated by Topographic Generator\n";
    file << "# Vertices: " << data.vertices.size() << "\n";
    file << "# Faces: " << data.faces.size() << "\n\n";
    
    // Write material library reference
    if (options_.include_materials && !data.materials.empty()) {
        std::string mtl_name = filename.substr(0, filename.find_last_of('.')) + ".mtl";
        std::string mtl_basename = mtl_name.substr(mtl_name.find_last_of('/') + 1);
        file << "mtllib " << mtl_basename << "\n\n";
    }
    
    // Write vertices
    file << "# Vertices\n";
    for (const auto& vertex : data.vertices) {
        file << "v " << vertex.x() << " " << vertex.y() << " " << vertex.z() << "\n";
    }
    file << "\n";
    
    // Write texture coordinates
    if (options_.include_texture_coords && !data.texture_coords.empty()) {
        file << "# Texture coordinates\n";
        for (const auto& tc : data.texture_coords) {
            file << "vt " << tc[0] << " " << tc[1] << "\n";
        }
        file << "\n";
    }
    
    // Write normals
    if (options_.include_normals && !data.normals.empty()) {
        file << "# Normals\n";
        for (const auto& normal : data.normals) {
            file << "vn " << normal.x() << " " << normal.y() << " " << normal.z() << "\n";
        }
        file << "\n";
    }
    
    // Write faces
    file << "# Faces\n";
    std::string current_material = "";
    
    for (size_t i = 0; i < data.faces.size(); ++i) {
        const auto& face = data.faces[i];
        
        // Set material if needed
        if (options_.include_materials && i < data.material_ids.size()) {
            int material_id = data.material_ids[i];
            if (material_id >= 0 && material_id < static_cast<int>(data.materials.size())) {
                const std::string& material_name = data.materials[material_id].name;
                if (material_name != current_material) {
                    file << "usemtl " << material_name << "\n";
                    current_material = material_name;
                }
            }
        }
        
        // Write face (1-based indexing)
        file << "f ";
        for (int j = 0; j < 3; ++j) {
            int vertex_idx = face[j] + 1;
            file << vertex_idx;
            
            if (options_.include_texture_coords) {
                file << "/" << vertex_idx;
            }
            
            if (options_.include_normals) {
                if (!options_.include_texture_coords) {
                    file << "/";
                }
                file << "/" << vertex_idx;
            }
            
            if (j < 2) file << " ";
        }
        file << "\n";
    }
    
    file.close();
    return true;
}

bool OBJExporter::write_material_file(
    const std::vector<Material>& materials,
    const std::string& filename) const {
    
    std::ofstream file(filename);
    if (!file.is_open()) {
        return false;
    }
    
    file << std::fixed << std::setprecision(3);
    file << "# MTL file generated by Topographic Generator\n";
    file << "# Materials: " << materials.size() << "\n\n";
    
    for (const auto& material : materials) {
        file << "newmtl " << material.name << "\n";
        file << "Ka " << material.ambient[0] << " " 
             << material.ambient[1] << " " 
             << material.ambient[2] << "\n";
        file << "Kd " << material.diffuse[0] << " " 
             << material.diffuse[1] << " " 
             << material.diffuse[2] << "\n";
        file << "Ks " << material.specular[0] << " " 
             << material.specular[1] << " " 
             << material.specular[2] << "\n";
        file << "Ns " << material.shininess << "\n";
        
        if (material.diffuse_texture.has_value()) {
            file << "map_Kd " << material.diffuse_texture.value() << "\n";
        }
        
        file << "\n";
    }
    
    file.close();
    return true;
}

int OBJExporter::assign_material_by_elevation(
    double elevation,
    double min_elevation,
    double max_elevation,
    int num_materials) const {
    
    if (num_materials <= 1) {
        return 0;
    }
    
    double normalized = (elevation - min_elevation) / (max_elevation - min_elevation);
    normalized = std::clamp(normalized, 0.0, 1.0);
    
    int material_id = static_cast<int>(normalized * (num_materials - 1));
    return std::clamp(material_id, 0, num_materials - 1);
}

} // namespace topo