#pragma once

/**
 * @file MultiFormatExporter.hpp
 * @brief Multi-format export system supporting 3D mesh, raster, and vector formats
 *
 * Comprehensive export system that supports multiple file formats including:
 * - 3D: STL, OBJ, PLY, NURBS
 * - Raster: PNG, TIFF, GeoTIFF
 * - Vector: SVG, GeoJSON, Shapefile
 */

#include "topographic_generator.hpp"
#include "../core/ContourGenerator.hpp"
#include <fstream>
#include <iomanip>

namespace topo {

/**
 * @brief Material definition for OBJ export
 */
struct Material {
    std::string name;
    std::array<float, 3> ambient{0.2f, 0.2f, 0.2f};   // Ka
    std::array<float, 3> diffuse{0.8f, 0.8f, 0.8f};   // Kd  
    std::array<float, 3> specular{0.0f, 0.0f, 0.0f};  // Ks
    float shininess = 1.0f;                            // Ns
    std::optional<std::string> diffuse_texture;        // map_Kd
    
    Material(const std::string& mat_name) : name(mat_name) {}
};

/**
 * @brief Color mapping strategies for elevation-based coloring
 */
class ColorMapper {
public:
    enum class Scheme {
        GRAYSCALE,      // Simple grayscale based on elevation
        TERRAIN,        // Brown-green-white terrain colors
        RAINBOW,        // Full spectrum rainbow
        TOPOGRAPHIC,    // Traditional topographic map colors
        HYPSOMETRIC,    // Hypsometric tints
        CUSTOM          // User-defined color stops
    };
    
    struct ColorStop {
        double elevation;
        std::array<float, 3> color;
    };
    
    explicit ColorMapper(Scheme scheme = Scheme::TERRAIN);
    ColorMapper(const std::vector<ColorStop>& custom_stops);
    
    std::array<float, 3> map_elevation_to_color(double elevation,
                                               double min_elevation,
                                               double max_elevation) const;
    
    std::vector<Material> generate_elevation_materials(
        double min_elevation,
        double max_elevation,
        int num_bands = 10) const;
        
    void set_scheme(Scheme scheme);

private:
    Scheme scheme_;
    std::vector<ColorStop> color_stops_;
    void initialize_color_stops(Scheme scheme);
};

/**
 * @brief STL export with binary and ASCII support
 */
class STLExporter {
public:
    struct Options {
        bool binary_format;
        bool validate_mesh;
        std::string header;
        std::string solid_name;
        bool auto_scale = true;                    // Automatically scale to fit print bed
        double scale_factor = 1.0;                // Manual scale factor if auto_scale=false
        double target_bed_size_mm = 200.0;        // Target print bed size for auto scaling

        Options() : binary_format(true), validate_mesh(true),
                   header("Generated by Topographic Generator"), solid_name("topographic_model") {}
    };
    
    explicit STLExporter(const Options& opts = Options()) : options_(opts) {}
    
    bool export_mesh(const TopographicMesh& mesh, 
                     const std::string& filename) const;
    
    // Export with custom coordinate transformation
    bool export_mesh_transformed(const TopographicMesh& mesh,
                                const std::string& filename,
                                const Eigen::Matrix4d& transform) const;
    
    // Legacy method names for compatibility
    bool export_stl(const TopographicMesh& mesh, const std::string& filename);
    bool write_ascii_stl(const TopographicMesh& mesh, const std::string& filename);
    bool write_binary_stl(const TopographicMesh& mesh, const std::string& filename);

private:
    Options options_;
    
    bool export_binary_stl(const TopographicMesh& mesh,
                          std::ofstream& file) const;
    bool export_ascii_stl(const TopographicMesh& mesh,
                         std::ofstream& file) const;
                         
    // Implementation methods
    bool write_binary_stl(const TopographicMesh& mesh, const std::string& filename) const;
    bool write_ascii_stl(const TopographicMesh& mesh, const std::string& filename) const;
    
    void write_triangle_binary(std::ofstream& file,
                              const Triangle& triangle,
                              const std::vector<Vertex3D>& vertices) const;
    void write_triangle_ascii(std::ofstream& file,
                             const Triangle& triangle,
                             const std::vector<Vertex3D>& vertices) const;

    // Scaling helper methods
    double calculate_scale_factor(const TopographicMesh& mesh) const;
    Point3D scale_vertex(const Point3D& vertex, const BoundingBox& bbox, double scale_factor) const;
};

/**
 * @brief OBJ export with materials, textures, and colors
 */
class OBJExporter {
public:
    struct Options {
        bool include_materials;
        bool elevation_coloring;
        bool include_normals;
        bool include_texture_coords;
        ColorMapper::Scheme color_scheme;
        int elevation_bands;
        std::string material_library_name; // Auto-generated if empty
        
        Options() : include_materials(true), elevation_coloring(true), include_normals(true),
                   include_texture_coords(false), color_scheme(ColorMapper::Scheme::TERRAIN),
                   elevation_bands(20) {}
    };
    
    explicit OBJExporter(const Options& opts = Options()) : options_(opts) {}
    
    bool export_mesh(const TopographicMesh& mesh,
                     const std::string& filename) const;
                     
    // Legacy method name for compatibility
    bool export_obj(const TopographicMesh& mesh, const std::string& filename) const;
    
    // Export with elevation-based materials
    bool export_mesh_with_elevation_materials(
        const TopographicMesh& mesh,
        const std::string& filename,
        double min_elevation,
        double max_elevation) const;
    
    // Export multiple layers as separate objects
    bool export_layers(const std::vector<TopographicMesh>& layers,
                      const std::string& filename,
                      const std::vector<std::string>& layer_names = {}) const;

private:
    Options options_;
    
    struct ExportData {
        std::vector<Point3D> vertices;
        std::vector<Vector3D> normals;
        std::vector<std::array<float, 2>> texture_coords;
        std::vector<std::array<int, 3>> faces;
        std::vector<int> material_ids;
        std::vector<Material> materials;
    };
    
    ExportData prepare_export_data(const TopographicMesh& mesh,
                                  double min_elevation,
                                  double max_elevation) const;
    
    bool write_obj_file(const ExportData& data,
                       const std::string& filename) const;
    
    bool write_material_file(const std::vector<Material>& materials,
                            const std::string& filename) const;
    
    int assign_material_by_elevation(double elevation,
                                   double min_elevation,
                                   double max_elevation,
                                   int num_materials) const;
};

/**
 * @brief PLY export for research and visualization applications
 */
class PLYExporter {
public:
    struct Options {
        bool binary_format;
        bool include_colors;
        bool include_normals;
        ColorMapper::Scheme color_scheme;
        
        Options() : binary_format(true), include_colors(true), include_normals(true),
                   color_scheme(ColorMapper::Scheme::TERRAIN) {}
    };
    
    explicit PLYExporter(const Options& opts = Options()) : options_(opts) {}
    
    bool export_mesh(const TopographicMesh& mesh,
                     const std::string& filename) const;

private:
    Options options_;
    
    bool export_binary_ply(const TopographicMesh& mesh,
                          std::ofstream& file,
                          double min_elevation,
                          double max_elevation) const;
    bool export_ascii_ply(const TopographicMesh& mesh,
                         std::ofstream& file,
                         double min_elevation,
                         double max_elevation) const;
};

/**
 * @brief NURBS surface export for CAD applications
 */
class NURBSExporter {
public:
    enum class Quality {
        DRAFT,          // Fast, lower quality
        MEDIUM,         // Balanced quality/performance
        HIGH,           // High quality, slower
        ULTRA           // Maximum quality
    };
    
    enum class Format {
        IGES,           // Industry standard
        STEP,           // Modern CAD standard
        NURBS_NATIVE    // Custom NURBS format
    };
    
    struct Options {
        Quality quality;
        int u_degree;           // U-direction degree
        int v_degree;           // V-direction degree
        double fitting_tolerance;
        bool smooth_surface;
        
        Options() : quality(Quality::MEDIUM), u_degree(3), v_degree(3),
                   fitting_tolerance(0.1), smooth_surface(true) {}
    };
    
    explicit NURBSExporter(const Options& opts = Options()) : options_(opts) {}
    
    // Convert mesh to NURBS surface
    bool convert_mesh_to_nurbs(const TopographicMesh& mesh);
    
    // Export to various formats
    bool export_iges(const std::string& filename) const;
    bool export_step(const std::string& filename) const;
    bool export_nurbs_native(const std::string& filename) const;
    
    // Multi-format export
    bool export_all_formats(const std::string& base_filename) const;
    
    // Surface quality metrics
    struct SurfaceMetrics {
        double average_fitting_error;
        double max_fitting_error;
        int num_control_points_u;
        int num_control_points_v;
        bool is_smooth;
    };
    
    SurfaceMetrics get_surface_metrics() const;

private:
    Options options_;
    
    // NURBS export disabled - would require CGAL or OpenCASCADE
    // std::unique_ptr<CGAL::Surface_mesh<Point3D>> nurbs_surface_;
    bool surface_generated_ = false;

    // Reference to original mesh for error calculations (reserved for future use)
    [[maybe_unused]] const TopographicMesh* original_mesh_ = nullptr;

    // Surface fitting algorithms
    bool fit_nurbs_surface_cgal(const TopographicMesh& mesh);
    bool fit_nurbs_surface_custom(const TopographicMesh& mesh);
    
    // Format-specific writers
    bool write_iges_format(const std::string& filename) const;
    bool write_step_format(const std::string& filename) const;
    bool write_nurbs_native_format(const std::string& filename) const;
    
    // Surface optimization
    void optimize_surface_smoothness();
    void refine_surface_locally(const std::vector<Point3D>& problem_areas);

    // Quality analysis
    void calculate_fitting_errors(SurfaceMetrics& metrics) const;
    bool check_surface_smoothness() const;
};

/**
 * @brief Main multi-format export coordinator
 */
class MultiFormatExporter {
public:
    struct GlobalOptions {
        std::string output_directory;
        std::string base_filename;
        std::string filename_pattern;  // Pattern for output filenames (empty = use default)
        bool validate_before_export;
        bool generate_thumbnails;
        bool create_export_report;
        bool verbose;
        bool output_individual_layers;

        GlobalOptions() : output_directory("output"), base_filename("topographic_model"),
                         filename_pattern(""),
                         validate_before_export(true), generate_thumbnails(false),
                         create_export_report(true), verbose(false), output_individual_layers(true) {}
    };
    
    explicit MultiFormatExporter(const GlobalOptions& opts = GlobalOptions());
    
    // Single format exports
    bool export_stl(const TopographicMesh& mesh,
                   const STLExporter::Options& options = STLExporter::Options()) const;
    
    bool export_obj(const TopographicMesh& mesh,
                   const OBJExporter::Options& options = OBJExporter::Options()) const;
    
    bool export_ply(const TopographicMesh& mesh,
                   const PLYExporter::Options& options = PLYExporter::Options()) const;
    
    bool export_nurbs(const TopographicMesh& mesh,
                     const NURBSExporter::Options& options = NURBSExporter::Options()) const;

    // Raster format exports (require contour layers)
    bool export_png(const std::vector<ContourLayer>& layers,
                   const BoundingBox& bounds);

    bool export_geotiff(const std::vector<ContourLayer>& layers,
                       const BoundingBox& bounds);

    // Vector format exports (require contour layers)
    bool export_geojson(const std::vector<ContourLayer>& layers);

    bool export_shapefile(const std::vector<ContourLayer>& layers);

    // Multi-format export
    bool export_all_formats(const TopographicMesh& mesh,
                           const std::vector<std::string>& requested_formats) const;
                           
    // Legacy method name for compatibility
    bool export_all_formats(const TopographicMesh& mesh, 
                            const std::vector<std::string>& formats);
    
    // Batch export for multiple meshes (layers)
    bool export_layers(const std::vector<TopographicMesh>& meshes,
                      const std::vector<std::string>& formats) const;
    
    // Export statistics and reporting
    struct ExportReport {
        std::map<std::string, bool> format_success;
        std::map<std::string, std::chrono::milliseconds> export_times;
        std::map<std::string, size_t> file_sizes;
        std::vector<std::string> warnings;
        std::vector<std::string> errors;
        
        bool all_successful() const {
            return std::all_of(format_success.begin(), format_success.end(),
                             [](const auto& pair) { return pair.second; });
        }
    };
    
    const ExportReport& get_last_report() const { return last_report_; }
    
    // Configuration
    void set_stl_options(const STLExporter::Options& options) { stl_options_ = options; }
    void set_obj_options(const OBJExporter::Options& options) { obj_options_ = options; }
    void set_ply_options(const PLYExporter::Options& options) { ply_options_ = options; }
    void set_nurbs_options(const NURBSExporter::Options& options) { nurbs_options_ = options; }

private:
    GlobalOptions global_options_;
    STLExporter::Options stl_options_;
    OBJExporter::Options obj_options_;
    PLYExporter::Options ply_options_;
    NURBSExporter::Options nurbs_options_;
    
    mutable ExportReport last_report_;
    
    // Export helpers
    std::string generate_filename(const std::string& format) const;
    bool validate_output_directory() const;
    void generate_export_report(const ExportReport& report) const;
    
    // Format validation
    bool is_format_supported(const std::string& format) const;
    std::vector<std::string> get_supported_formats() const;
};

} // namespace topo