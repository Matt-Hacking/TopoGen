/**
 * @file PLYExporter.cpp
 * @brief Implementation of PLY (Stanford Triangle Format) export
 */

#include "MultiFormatExporter.hpp"
#include "../core/TopographicMesh.hpp"
#include <fstream>
#include <iomanip>

namespace topo {

// ============================================================================
// PLYExporter Implementation
// ============================================================================

bool PLYExporter::export_mesh(const TopographicMesh& mesh, const std::string& filename) const {
    std::ofstream file(filename, options_.binary_format ? std::ios::binary : std::ios::out);
    if (!file.is_open()) {
        return false;
    }
    
    // Compute elevation range for coloring
    auto bbox = mesh.compute_bounding_box();
    double min_elevation = bbox.min_z.value_or(0.0);
    double max_elevation = bbox.max_z.value_or(100.0);
    
    if (options_.binary_format) {
        return export_binary_ply(mesh, file, min_elevation, max_elevation);
    } else {
        return export_ascii_ply(mesh, file, min_elevation, max_elevation);
    }
}

bool PLYExporter::export_ascii_ply(const TopographicMesh& mesh, std::ofstream& file, double min_elevation, double max_elevation) const {
    
    file << std::fixed << std::setprecision(6);
    
    // Count valid triangles
    size_t valid_triangles = 0;
    for (size_t i = 0; i < mesh.num_triangles(); ++i) {
        const auto& triangle = mesh.get_triangle(static_cast<TriangleId>(i));
        if (triangle.vertices[0] != static_cast<VertexId>(-1)) {
            valid_triangles++;
        }
    }
    
    // Write PLY header
    file << "ply\n";
    file << "format ascii 1.0\n";
    file << "comment Generated by Topographic Generator\n";
    file << "element vertex " << mesh.num_vertices() << "\n";
    file << "property float x\n";
    file << "property float y\n";
    file << "property float z\n";
    
    if (options_.include_normals) {
        file << "property float nx\n";
        file << "property float ny\n";
        file << "property float nz\n";
    }
    
    if (options_.include_colors) {
        file << "property uchar red\n";
        file << "property uchar green\n";
        file << "property uchar blue\n";
    }
    
    file << "element face " << valid_triangles << "\n";
    file << "property list uchar int vertex_indices\n";
    file << "end_header\n";
    
    // Write vertices
    for (size_t i = 0; i < mesh.num_vertices(); ++i) {
        const auto& vertex = mesh.get_vertex(static_cast<VertexId>(i));
        file << vertex.position.x() << " " << vertex.position.y() << " " << vertex.position.z();
        
        if (options_.include_normals) {
            file << " " << vertex.normal.x() << " " << vertex.normal.y() << " " << vertex.normal.z();
        }
        
        if (options_.include_colors) {
            // Convert elevation to color (simple gradient)
            double normalized = (vertex.position.z() - min_elevation) / (max_elevation - min_elevation);
            normalized = std::clamp(normalized, 0.0, 1.0);
            
            int color_value = static_cast<int>(255 * normalized);
            file << " " << color_value << " " << (255 - color_value) << " 0";
        }
        
        file << "\n";
    }
    
    // Write faces
    for (size_t i = 0; i < mesh.num_triangles(); ++i) {
        const auto& triangle = mesh.get_triangle(static_cast<TriangleId>(i));
        
        if (triangle.vertices[0] == static_cast<VertexId>(-1)) {
            continue; // Skip invalid triangles
        }
        
        file << "3 " << triangle.vertices[0] << " " << triangle.vertices[1] << " " << triangle.vertices[2] << "\n";
    }
    
    return true;
}

bool PLYExporter::export_binary_ply(const TopographicMesh& mesh, std::ofstream& file, double min_elevation, double max_elevation) const {
    
    // Count valid triangles
    size_t valid_triangles = 0;
    for (size_t i = 0; i < mesh.num_triangles(); ++i) {
        const auto& triangle = mesh.get_triangle(static_cast<TriangleId>(i));
        if (triangle.vertices[0] != static_cast<VertexId>(-1)) {
            valid_triangles++;
        }
    }
    
    // Write PLY header (text portion)
    std::string header = "ply\n";
    header += "format binary_little_endian 1.0\n";
    header += "comment Generated by Topographic Generator\n";
    header += "element vertex " + std::to_string(mesh.num_vertices()) + "\n";
    header += "property float x\n";
    header += "property float y\n";
    header += "property float z\n";
    
    if (options_.include_normals) {
        header += "property float nx\n";
        header += "property float ny\n";
        header += "property float nz\n";
    }
    
    if (options_.include_colors) {
        header += "property uchar red\n";
        header += "property uchar green\n";
        header += "property uchar blue\n";
    }
    
    header += "element face " + std::to_string(valid_triangles) + "\n";
    header += "property list uchar int vertex_indices\n";
    header += "end_header\n";
    
    file.write(header.c_str(), header.length());
    
    // Write vertices (binary)
    for (size_t i = 0; i < mesh.num_vertices(); ++i) {
        const auto& vertex = mesh.get_vertex(static_cast<VertexId>(i));
        
        float pos[3] = {
            static_cast<float>(vertex.position.x()),
            static_cast<float>(vertex.position.y()),
            static_cast<float>(vertex.position.z())
        };
        file.write(reinterpret_cast<const char*>(pos), sizeof(pos));
        
        if (options_.include_normals) {
            float normal[3] = {
                static_cast<float>(vertex.normal.x()),
                static_cast<float>(vertex.normal.y()),
                static_cast<float>(vertex.normal.z())
            };
            file.write(reinterpret_cast<const char*>(normal), sizeof(normal));
        }
        
        if (options_.include_colors) {
            // Convert elevation to color
            double normalized = (vertex.position.z() - min_elevation) / (max_elevation - min_elevation);
            normalized = std::clamp(normalized, 0.0, 1.0);
            
            unsigned char colors[3] = {
                static_cast<unsigned char>(255 * normalized),
                static_cast<unsigned char>(255 * (1.0 - normalized)),
                0
            };
            file.write(reinterpret_cast<const char*>(colors), sizeof(colors));
        }
    }
    
    // Write faces (binary)
    for (size_t i = 0; i < mesh.num_triangles(); ++i) {
        const auto& triangle = mesh.get_triangle(static_cast<TriangleId>(i));
        
        if (triangle.vertices[0] == static_cast<VertexId>(-1)) {
            continue; // Skip invalid triangles
        }
        
        unsigned char vertex_count = 3;
        file.write(reinterpret_cast<const char*>(&vertex_count), sizeof(vertex_count));
        
        int indices[3] = {
            static_cast<int>(triangle.vertices[0]),
            static_cast<int>(triangle.vertices[1]),
            static_cast<int>(triangle.vertices[2])
        };
        file.write(reinterpret_cast<const char*>(indices), sizeof(indices));
    }
    
    return true;
}

} // namespace topo